From 0cfd5e90f0fb354413510cd0ca35d862fb8fc077 Mon Sep 17 00:00:00 2001
Message-ID: <0cfd5e90f0fb354413510cd0ca35d862fb8fc077.1692295361.git.lorenzo@kernel.org>
From: Sujuan Chen <sujuan.chen@mediatek.com>
Date: Sat, 22 Jul 2023 23:06:25 +0200
Subject: [PATCH net-next 1/2] net: ethernet: mtk_wed: introduce pao support
 for MT7988 (WIP)

Co-developed-by: Lorenzo Bianconi <lorenzo@kernel.org>
Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
Signed-off-by: Sujuan Chen <sujuan.chen@mediatek.com>
---
 drivers/net/ethernet/mediatek/mtk_ppe.c       |   4 +-
 drivers/net/ethernet/mediatek/mtk_ppe.h       |   3 +-
 .../net/ethernet/mediatek/mtk_ppe_offload.c   |   3 +-
 drivers/net/ethernet/mediatek/mtk_wed.c       | 154 ++++++++++++++++--
 drivers/net/ethernet/mediatek/mtk_wed.h       |   7 +
 include/linux/netdevice.h                     |   1 +
 include/linux/soc/mediatek/mtk_wed.h          |   3 +
 7 files changed, 155 insertions(+), 20 deletions(-)

diff --git a/drivers/net/ethernet/mediatek/mtk_ppe.c b/drivers/net/ethernet/mediatek/mtk_ppe.c
index bf1ecb0c1c10..6f65b6cc1c0e 100644
--- a/drivers/net/ethernet/mediatek/mtk_ppe.c
+++ b/drivers/net/ethernet/mediatek/mtk_ppe.c
@@ -418,7 +418,8 @@ int mtk_foe_entry_set_pppoe(struct mtk_eth *eth, struct mtk_foe_entry *entry,
 }
 
 int mtk_foe_entry_set_wdma(struct mtk_eth *eth, struct mtk_foe_entry *entry,
-			   int wdma_idx, int txq, int bss, int wcid)
+			   int wdma_idx, int txq, int bss, int wcid,
+			   bool amsdu)
 {
 	struct mtk_foe_mac_info *l2 = mtk_foe_entry_l2(eth, entry);
 	u32 *ib2 = mtk_foe_entry_ib2(eth, entry);
@@ -430,6 +431,7 @@ int mtk_foe_entry_set_wdma(struct mtk_eth *eth, struct mtk_foe_entry *entry,
 			 MTK_FOE_IB2_WDMA_WINFO_V2;
 		l2->w3info = FIELD_PREP(MTK_FOE_WINFO_WCID_V3, wcid) |
 			     FIELD_PREP(MTK_FOE_WINFO_BSS_V3, bss);
+		l2->wpao = FIELD_PREP(MTK_FOE_WINFO_PAO_AMSDU_EN, amsdu);
 		break;
 	case 2:
 		*ib2 &= ~MTK_FOE_IB2_PORT_MG_V2;
diff --git a/drivers/net/ethernet/mediatek/mtk_ppe.h b/drivers/net/ethernet/mediatek/mtk_ppe.h
index e3d0ec72bc69..9cb4a2101b1f 100644
--- a/drivers/net/ethernet/mediatek/mtk_ppe.h
+++ b/drivers/net/ethernet/mediatek/mtk_ppe.h
@@ -392,7 +392,8 @@ int mtk_foe_entry_set_vlan(struct mtk_eth *eth, struct mtk_foe_entry *entry,
 int mtk_foe_entry_set_pppoe(struct mtk_eth *eth, struct mtk_foe_entry *entry,
 			    int sid);
 int mtk_foe_entry_set_wdma(struct mtk_eth *eth, struct mtk_foe_entry *entry,
-			   int wdma_idx, int txq, int bss, int wcid);
+			   int wdma_idx, int txq, int bss, int wcid,
+			   bool amsdu);
 int mtk_foe_entry_set_queue(struct mtk_eth *eth, struct mtk_foe_entry *entry,
 			    unsigned int queue);
 int mtk_foe_entry_commit(struct mtk_ppe *ppe, struct mtk_flow_entry *entry);
diff --git a/drivers/net/ethernet/mediatek/mtk_ppe_offload.c b/drivers/net/ethernet/mediatek/mtk_ppe_offload.c
index 23f4cdc3844d..b42329ba5e85 100644
--- a/drivers/net/ethernet/mediatek/mtk_ppe_offload.c
+++ b/drivers/net/ethernet/mediatek/mtk_ppe_offload.c
@@ -111,6 +111,7 @@ mtk_flow_get_wdma_info(struct net_device *dev, const u8 *addr, struct mtk_wdma_i
 	info->queue = path->mtk_wdma.queue;
 	info->bss = path->mtk_wdma.bss;
 	info->wcid = path->mtk_wdma.wcid;
+	info->amsdu = path->mtk_wdma.amsdu;
 
 	return 0;
 }
@@ -192,7 +193,7 @@ mtk_flow_set_output_device(struct mtk_eth *eth, struct mtk_foe_entry *foe,
 
 	if (mtk_flow_get_wdma_info(dev, dest_mac, &info) == 0) {
 		mtk_foe_entry_set_wdma(eth, foe, info.wdma_idx, info.queue,
-				       info.bss, info.wcid);
+				       info.bss, info.wcid, info.amsdu);
 		if (mtk_is_netsys_v2_or_greater(eth)) {
 			switch (info.wdma_idx) {
 			case 0:
diff --git a/drivers/net/ethernet/mediatek/mtk_wed.c b/drivers/net/ethernet/mediatek/mtk_wed.c
index cc817b4f57e3..64e88c0867f3 100644
--- a/drivers/net/ethernet/mediatek/mtk_wed.c
+++ b/drivers/net/ethernet/mediatek/mtk_wed.c
@@ -29,6 +29,8 @@
 #define MTK_WED_RX_PAGE_BUF_PER_PAGE	(PAGE_SIZE / 128)
 #define MTK_WED_RX_RING_SIZE		1536
 #define MTK_WED_RX_PG_BM_CNT		8192
+#define MTK_WED_PAO_BUF_SIZE		(PAGE_SIZE << 4)
+#define MTK_WED_PAO_NPAGES		32
 
 #define MTK_WED_TX_RING_SIZE		2048
 #define MTK_WED_WDMA_RING_SIZE		1024
@@ -139,6 +141,23 @@ mtk_wdma_rx_reset(struct mtk_wed_device *dev)
 	return ret;
 }
 
+static u32
+mtk_wed_check_busy(struct mtk_wed_device *dev, u32 reg, u32 mask)
+{
+	return !!(wed_r32(dev, reg) & mask);
+}
+
+static int
+mtk_wed_poll_busy(struct mtk_wed_device *dev, u32 reg, u32 mask)
+{
+	int sleep = 15000;
+	int timeout = 100 * sleep;
+	u32 val;
+
+	return read_poll_timeout(mtk_wed_check_busy, val, !val, sleep,
+				 timeout, false, dev, reg, mask);
+}
+
 static void
 mtk_wdma_tx_reset(struct mtk_wed_device *dev)
 {
@@ -301,6 +320,118 @@ mtk_wed_assign(struct mtk_wed_device *dev)
 	return hw;
 }
 
+static int
+mtk_wed_pao_buffer_alloc(struct mtk_wed_device *dev)
+{
+	struct mtk_wed_hw *hw = dev->hw;
+	struct mtk_wed_pao *pao;
+	int i;
+
+	if (hw->version < 3)
+		return 0;
+
+	pao = devm_kcalloc(hw->dev, MTK_WED_PAO_NPAGES, sizeof(*pao),
+			   GFP_KERNEL);
+	if (!pao)
+		return -ENOMEM;
+
+	for (i = 0; i < MTK_WED_PAO_NPAGES; i++) {
+		void *data;
+
+		/* each segment is 64K */
+		data = (void *)__get_free_pages(GFP_KERNEL | __GFP_NOWARN |
+						__GFP_ZERO | __GFP_COMP |
+						GFP_DMA32,
+						get_order(MTK_WED_PAO_BUF_SIZE));
+		if (!data)
+			goto error;
+
+		pao[i].txd = data;
+		pao[i].txd_addr = dma_map_single(hw->dev, data,
+						 MTK_WED_PAO_BUF_SIZE,
+						 DMA_TO_DEVICE);
+		if (dma_mapping_error(hw->dev, pao[i].txd_addr))
+			goto error;
+	}
+	dev->hw->wed_pao = pao;
+
+	return 0;
+
+error:
+	for (i--; i >= 0; i--)
+		dma_unmap_single(hw->dev, pao[i].txd_addr,
+				 MTK_WED_PAO_BUF_SIZE, DMA_TO_DEVICE);
+	return -ENOMEM;
+}
+
+static void
+mtk_wed_pao_free_buffer(struct mtk_wed_device *dev)
+{
+	struct mtk_wed_pao *pao = dev->hw->wed_pao;
+	int i;
+
+	if (!pao)
+		return;
+
+	for (i = 0; i < MTK_WED_PAO_NPAGES; i++) {
+		dma_unmap_single(dev->hw->dev, pao[i].txd_addr,
+				 MTK_WED_PAO_BUF_SIZE, DMA_TO_DEVICE);
+		free_pages((unsigned long)pao[i].txd,
+			   get_order(MTK_WED_PAO_BUF_SIZE));
+	}
+}
+
+static int
+mtk_wed_pao_init(struct mtk_wed_device *dev)
+{
+	struct mtk_wed_pao *pao = dev->hw->wed_pao;
+	int i, ret;
+
+	if (!pao)
+		return 0;
+
+	for (i = 0; i < MTK_WED_PAO_NPAGES; i++)
+		wed_w32(dev, MTK_WED_PAO_HIFTXD_BASE_L(i), pao[i].txd_addr);
+
+	/* init all sta parameter */
+	wed_w32(dev, MTK_WED_PAO_STA_INFO_INIT, MTK_WED_PAO_STA_RMVL |
+		MTK_WED_PAO_STA_WTBL_HDRT_MODE |
+		FIELD_PREP(MTK_WED_PAO_STA_MAX_AMSDU_LEN,
+			   dev->wlan.amsdu_max_len >> 8) |
+		FIELD_PREP(MTK_WED_PAO_STA_MAX_AMSDU_NUM,
+			   dev->wlan.amsdu_max_subframes));
+
+	wed_w32(dev, MTK_WED_PAO_STA_INFO, MTK_WED_PAO_STA_INFO_DO_INIT);
+
+	ret = mtk_wed_poll_busy(dev, MTK_WED_PAO_STA_INFO,
+				MTK_WED_PAO_STA_INFO_DO_INIT);
+	if (ret) {
+		dev_err(dev->hw->dev, "mtk-pao initialization failed\n");
+		return ret;
+	}
+
+	/* init pao txd src */
+	wed_set(dev, MTK_WED_PAO_HIFTXD_CFG,
+		FIELD_PREP(MTK_WED_PAO_HIFTXD_SRC, dev->hw->index));
+
+	/* init qmem */
+	wed_set(dev, MTK_WED_PAO_PSE, MTK_WED_PAO_PSE_RESET);
+	ret = mtk_wed_poll_busy(dev, MTK_WED_PAO_MON_QMEM_STS1, BIT(29));
+	if (ret) {
+		pr_info("%s: pao qmem initialization failed\n", __func__);
+		return ret;
+	}
+
+	/* eagle E1 PCIE1 tx ring 22 flow control issue */
+	if (dev->wlan.id == 0x7991)
+		wed_clr(dev, MTK_WED_PAO_AMSDU_FIFO,
+			MTK_WED_PAO_AMSDU_IS_PRIOR0_RING);
+
+	wed_set(dev, MTK_WED_CTRL, MTK_WED_CTRL_TX_PAO_EN);
+
+	return 0;
+}
+
 static int
 mtk_wed_tx_buffer_alloc(struct mtk_wed_device *dev)
 {
@@ -672,6 +803,7 @@ __mtk_wed_detach(struct mtk_wed_device *dev)
 	mtk_wdma_rx_reset(dev);
 	mtk_wed_reset(dev, MTK_WED_RESET_WED);
 	mtk_wed_free_tx_buffer(dev);
+	mtk_wed_pao_free_buffer(dev);
 	mtk_wed_free_tx_rings(dev);
 
 	if (mtk_wed_get_rx_capa(dev)) {
@@ -1098,23 +1230,6 @@ mtk_wed_ring_reset(struct mtk_wed_ring *ring, int size, bool tx)
 	}
 }
 
-static u32
-mtk_wed_check_busy(struct mtk_wed_device *dev, u32 reg, u32 mask)
-{
-	return !!(wed_r32(dev, reg) & mask);
-}
-
-static int
-mtk_wed_poll_busy(struct mtk_wed_device *dev, u32 reg, u32 mask)
-{
-	int sleep = 15000;
-	int timeout = 100 * sleep;
-	u32 val;
-
-	return read_poll_timeout(mtk_wed_check_busy, val, !val, sleep,
-				 timeout, false, dev, reg, mask);
-}
-
 static int
 mtk_wed_rx_reset(struct mtk_wed_device *dev)
 {
@@ -1676,6 +1791,7 @@ mtk_wed_start(struct mtk_wed_device *dev, u32 irq_mask)
 	}
 
 	mtk_wed_set_512_support(dev, dev->wlan.wcid_512);
+	mtk_wed_pao_init(dev);
 
 	mtk_wed_dma_enable(dev);
 	dev->running = true;
@@ -1732,6 +1848,10 @@ mtk_wed_attach(struct mtk_wed_device *dev)
 	if (ret)
 		goto out;
 
+	ret = mtk_wed_pao_buffer_alloc(dev);
+	if (ret)
+		goto out;
+
 	if (mtk_wed_get_rx_capa(dev)) {
 		ret = mtk_wed_rro_alloc(dev);
 		if (ret)
diff --git a/drivers/net/ethernet/mediatek/mtk_wed.h b/drivers/net/ethernet/mediatek/mtk_wed.h
index fc59939af7a7..ed672ec6d742 100644
--- a/drivers/net/ethernet/mediatek/mtk_wed.h
+++ b/drivers/net/ethernet/mediatek/mtk_wed.h
@@ -14,6 +14,11 @@
 struct mtk_eth;
 struct mtk_wed_wo;
 
+struct mtk_wed_pao {
+	void *txd;
+	dma_addr_t txd_addr;
+};
+
 struct mtk_wed_hw {
 	struct device_node *node;
 	struct mtk_eth *eth;
@@ -26,6 +31,7 @@ struct mtk_wed_hw {
 	struct dentry *debugfs_dir;
 	struct mtk_wed_device *wed_dev;
 	struct mtk_wed_wo *wed_wo;
+	struct mtk_wed_pao *wed_pao;
 	u32 pcie_base;
 	u32 debugfs_reg;
 	u32 num_flows;
@@ -40,6 +46,7 @@ struct mtk_wdma_info {
 	u8 queue;
 	u16 wcid;
 	u8 bss;
+	u8 amsdu;
 };
 
 static inline u32 mtk_wed_get_pcie_base(struct mtk_wed_device *dev)
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index 11652e464f5d..621ac48547f8 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -939,6 +939,7 @@ struct net_device_path {
 			u8 queue;
 			u16 wcid;
 			u8 bss;
+			u8 amsdu;
 		} mtk_wdma;
 	};
 };
diff --git a/include/linux/soc/mediatek/mtk_wed.h b/include/linux/soc/mediatek/mtk_wed.h
index 68153593a682..b9f2aeeeada1 100644
--- a/include/linux/soc/mediatek/mtk_wed.h
+++ b/include/linux/soc/mediatek/mtk_wed.h
@@ -129,6 +129,7 @@ struct mtk_wed_device {
 		enum mtk_wed_bus_tye bus_type;
 		void __iomem *base;
 		u32 phy_base;
+		u32 id;
 
 		u32 wpdma_phys;
 		u32 wpdma_int;
@@ -149,10 +150,12 @@ struct mtk_wed_device {
 		unsigned int rx_nbuf;
 		unsigned int rx_npkt;
 		unsigned int rx_size;
+		unsigned int amsdu_max_len;
 
 		u8 tx_tbit[MTK_WED_TX_QUEUES];
 		u8 rx_tbit[MTK_WED_RX_QUEUES];
 		u8 txfree_tbit;
+		u8 amsdu_max_subframes;
 
 		u32 (*init_buf)(void *ptr, dma_addr_t phys, int token_id);
 		int (*offload_enable)(struct mtk_wed_device *wed);
-- 
2.41.0

