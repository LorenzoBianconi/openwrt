--- /dev/null
+++ b/drivers/pci/controller/pcie-ecnt.c
@@ -0,0 +1,1156 @@
+/*
+ * MediaTek PCIe host controller driver.
+ *
+ * Copyright (c) 2017 MediaTek Inc.
+ * Author: Ryder Lee <ryder.lee@mediatek.com>
+ *	   Honghui Zhang <honghui.zhang@mediatek.com>
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/iopoll.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
+#include <linux/kernel.h>
+#include <linux/of_address.h>
+#include <linux/of_pci.h>
+#include <linux/of_platform.h>
+#include <linux/pci.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/reset.h>
+#include <linux/clk/en7523.h>
+
+/* PCIe shared registers */
+#define PCIE_SYS_CFG		0x00
+#define PCIE_INT_ENABLE		0x0c
+#define PCIE_CFG_ADDR		0x20
+#define PCIE_CFG_DATA		0x24
+
+/* PCIe per port registers */
+#define PCIE_BAR0_SETUP		0x10
+#define PCIE_CLASS		0x34
+#define PCIE_LINK_STATUS	0x50
+
+#define PCIE_PORT_INT_EN(x)	BIT(20 + (x))
+#define PCIE_PORT_PERST(x)	BIT(1 + (x))
+#define PCIE_PORT_LINKUP	BIT(0)
+#define PCIE_BAR_MAP_MAX	GENMASK(31, 16)
+
+#define PCIE_BAR_ENABLE		BIT(0)
+#define PCIE_REVISION_ID	BIT(0)
+#define PCIE_CLASS_CODE		(0x60400 << 8)
+#define PCIE_CONF_REG(regn)	(((regn) & GENMASK(7, 2)) | \
+				((((regn) >> 8) & GENMASK(3, 0)) << 24))
+#define PCIE_CONF_FUN(fun)	(((fun) << 8) & GENMASK(10, 8))
+#define PCIE_CONF_DEV(dev)	(((dev) << 11) & GENMASK(15, 11))
+#define PCIE_CONF_BUS(bus)	(((bus) << 16) & GENMASK(23, 16))
+#define PCIE_CONF_ADDR(regn, fun, dev, bus) \
+	(PCIE_CONF_REG(regn) | PCIE_CONF_FUN(fun) | \
+	 PCIE_CONF_DEV(dev) | PCIE_CONF_BUS(bus))
+
+/* MediaTek specific configuration registers */
+#define PCIE_FTS_NUM		0x70c
+#define PCIE_FTS_NUM_MASK	GENMASK(15, 8)
+#define PCIE_FTS_NUM_L0(x)	((x) & 0xff << 8)
+
+#define PCIE_FC_CREDIT		0x73c
+#define PCIE_FC_CREDIT_MASK	(GENMASK(31, 31) | GENMASK(28, 16))
+#define PCIE_FC_CREDIT_VAL(x)	((x) << 16)
+
+/* PCIe V2 share registers */
+#define PCIE_SYS_CFG_V2		0x0
+#define PCIE_CSR_LTSSM_EN(x)	BIT(0 + (x) * 8)
+#define PCIE_CSR_ASPM_L1_EN(x)	BIT(1 + (x) * 8)
+
+/* PCIe V2 per-port registers */
+#define PCIE_MSI_VECTOR		0x0c0
+
+#define K_GBL_1			0x000
+#define K_CONF_FUNC0_1		0x104
+
+#define PCIE_INT_MASK		0x420
+#define INTX_MASK		GENMASK(19, 16)
+#define INTX_SHIFT		16
+#define PCIE_INT_STATUS		0x424
+#define MSI_STATUS		BIT(23)
+#define PCIE_IMSI_STATUS	0x42c
+#define PCIE_IMSI_ADDR		0x430
+#define MSI_MASK		BIT(23)
+#define MTK_MSI_IRQS_NUM	32
+
+#define PCIE_AHB_TRANS_BASE0_L	0x438
+#define PCIE_AHB_TRANS_BASE0_H	0x43c
+#define AHB2PCIE_SIZE(x)	((x) & GENMASK(4, 0))
+#define PCIE_AXI_WINDOW0	0x448
+#define WIN_ENABLE		BIT(7)
+
+/* PCIe V2 configuration transaction header */
+#define PCIE_CFG_HEADER0	0x460
+#define PCIE_CFG_HEADER1	0x464
+#define PCIE_CFG_HEADER2	0x468
+#define PCIE_CFG_WDATA		0x470
+#define PCIE_APP_TLP_REQ	0x488
+#define PCIE_CFG_RDATA		0x48c
+#define APP_CFG_REQ		BIT(0)
+#define APP_CPL_STATUS		GENMASK(7, 5)
+
+#define CFG_WRRD_TYPE_0		4
+#define CFG_WR_FMT		2
+#define CFG_RD_FMT		0
+
+#define CFG_DW0_LENGTH(length)	((length) & GENMASK(9, 0))
+#define CFG_DW0_TYPE(type)	(((type) << 24) & GENMASK(28, 24))
+#define CFG_DW0_FMT(fmt)	(((fmt) << 29) & GENMASK(31, 29))
+#define CFG_DW2_REGN(regn)	((regn) & GENMASK(11, 2))
+#define CFG_DW2_FUN(fun)	(((fun) << 16) & GENMASK(18, 16))
+#define CFG_DW2_DEV(dev)	(((dev) << 19) & GENMASK(23, 19))
+#define CFG_DW2_BUS(bus)	(((bus) << 24) & GENMASK(31, 24))
+#define CFG_HEADER_DW0(type, fmt) \
+	(CFG_DW0_LENGTH(1) | CFG_DW0_TYPE(type) | CFG_DW0_FMT(fmt))
+#define CFG_HEADER_DW1(where, size) \
+	(GENMASK(((size) - 1), 0) << ((where) & 0x3))
+#define CFG_HEADER_DW2(regn, fun, dev, bus) \
+	(CFG_DW2_REGN(regn) | CFG_DW2_FUN(fun) | \
+	CFG_DW2_DEV(dev) | CFG_DW2_BUS(bus))
+
+#define PCIE_RST_CTRL		0x510
+#define PCIE_PHY_RSTB		BIT(0)
+#define PCIE_PIPE_SRSTB		BIT(1)
+#define PCIE_MAC_SRSTB		BIT(2)
+#define PCIE_CRSTB		BIT(3)
+#define PCIE_PERSTB		BIT(8)
+#define PCIE_LINKDOWN_RST_EN	GENMASK(15, 13)
+#define PCIE_LINK_STATUS_V2	0x804
+#define PCIE_PORT_LINKUP_V2	BIT(10)
+
+/**********************************************************/
+struct ecnt_pcie{
+	struct device *dev;
+	int irq_pcie0;
+	int irq_pcie1;
+	void __iomem *host0_base; /* PCIe Host0 base virtual address */
+	void __iomem *mac0_base; /* PCIe Mac0 base virtual address */
+	void __iomem *mac1_base; /* PCIe Mac1 base virtual address */
+};
+static struct ecnt_pcie ECNT_pcie;
+/**********************************************************/
+
+struct mtk_pcie_port;
+
+/**
+ * struct mtk_pcie_soc - differentiate between host generations
+ * @has_msi: whether this host supports MSI interrupts or not
+ * @ops: pointer to configuration access functions
+ * @startup: pointer to controller setting functions
+ * @setup_irq: pointer to initialize IRQ functions
+ */
+struct mtk_pcie_soc {
+	bool has_msi;
+	struct pci_ops *ops;
+	int (*startup)(struct mtk_pcie_port *port);
+	int (*setup_irq)(struct mtk_pcie_port *port, struct device_node *node);
+};
+
+/**
+ * struct mtk_pcie_port - PCIe port information
+ * @base: IO mapped register base
+ * @list: port list
+ * @pcie: pointer to PCIe host info
+ * @reset: pointer to port reset control
+ * @sys_ck: pointer to transaction/data link layer clock
+ * @ahb_ck: pointer to AHB slave interface operating clock for CSR access
+ *          and RC initiated MMIO access
+ * @axi_ck: pointer to application layer MMIO channel operating clock
+ * @aux_ck: pointer to pe2_mac_bridge and pe2_mac_core operating clock
+ *          when pcie_mac_ck/pcie_pipe_ck is turned off
+ * @obff_ck: pointer to OBFF functional block operating clock
+ * @pipe_ck: pointer to LTSSM and PHY/MAC layer operating clock
+ * @phy: pointer to PHY control block
+ * @lane: lane count
+ * @slot: port slot
+ * @irq_domain: legacy INTx IRQ domain
+ * @msi_domain: MSI IRQ domain
+ * @msi_irq_in_use: bit map for assigned MSI IRQ
+ */
+struct mtk_pcie_port {
+	void __iomem *base;
+	struct list_head list;
+	struct mtk_pcie *pcie;
+	struct reset_control *reset;
+	struct clk *sys_ck;
+	struct clk *ahb_ck;
+	struct clk *axi_ck;
+	struct clk *aux_ck;
+	struct clk *obff_ck;
+	struct clk *pipe_ck;
+	struct phy *phy;
+	u32 lane;
+	u32 slot;
+	struct irq_domain *irq_domain;
+	struct irq_domain *msi_domain;
+	DECLARE_BITMAP(msi_irq_in_use, MTK_MSI_IRQS_NUM);
+};
+
+/**
+ * struct mtk_pcie - PCIe host information
+ * @dev: pointer to PCIe device
+ * @base: IO mapped register base
+ * @free_ck: free-run reference clock
+ * @io: IO resource
+ * @pio: PIO resource
+ * @mem: non-prefetchable memory resource
+ * @busn: bus range
+ * @offset: IO / Memory offset
+ * @ports: pointer to PCIe port information
+ * @soc: pointer to SoC-dependent operations
+ */
+struct mtk_pcie {
+	struct device *dev;
+	void __iomem *base;
+	struct clk *free_ck;
+
+	struct resource io;
+	struct resource pio;
+	struct resource mem;
+	struct resource busn;
+	struct {
+		resource_size_t mem;
+		resource_size_t io;
+	} offset;
+	struct list_head ports;
+	const struct mtk_pcie_soc *soc;
+};
+
+
+static int mtk_pcie_check_cfg_cpld(struct mtk_pcie_port *port)
+{
+	u32 val;
+	int err;
+
+	err = readl_poll_timeout_atomic(port->base + PCIE_APP_TLP_REQ, val,
+					!(val & APP_CFG_REQ), 10,
+					100 * USEC_PER_MSEC);
+	if (err)
+		return PCIBIOS_SET_FAILED;
+
+	if (readl(port->base + PCIE_APP_TLP_REQ) & APP_CPL_STATUS)
+		return PCIBIOS_SET_FAILED;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int mtk_pcie_hw_rd_cfg(struct mtk_pcie_port *port, u32 bus, u32 devfn,
+			      int where, int size, u32 *val)
+{
+	u32 tmp;
+
+	/* Write PCIe configuration transaction header for Cfgrd */
+	writel(CFG_HEADER_DW0(CFG_WRRD_TYPE_0, CFG_RD_FMT),
+	       port->base + PCIE_CFG_HEADER0);
+	writel(CFG_HEADER_DW1(where, size), port->base + PCIE_CFG_HEADER1);
+	writel(CFG_HEADER_DW2(where, PCI_FUNC(devfn), PCI_SLOT(devfn), bus),
+	       port->base + PCIE_CFG_HEADER2);
+
+	/* Trigger h/w to transmit Cfgrd TLP */
+	tmp = readl(port->base + PCIE_APP_TLP_REQ);
+	tmp |= APP_CFG_REQ;
+	writel(tmp, port->base + PCIE_APP_TLP_REQ);
+
+	/* Check completion status */
+	if (mtk_pcie_check_cfg_cpld(port))
+		return PCIBIOS_SET_FAILED;
+
+	/* Read cpld payload of Cfgrd */
+	*val = readl(port->base + PCIE_CFG_RDATA);
+
+	if (size == 1)
+		*val = (*val >> (8 * (where & 3))) & 0xff;
+	else if (size == 2)
+		*val = (*val >> (8 * (where & 3))) & 0xffff;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int mtk_pcie_hw_wr_cfg(struct mtk_pcie_port *port, u32 bus, u32 devfn,
+			      int where, int size, u32 val)
+{
+	/* Write PCIe configuration transaction header for Cfgwr */
+	writel(CFG_HEADER_DW0(CFG_WRRD_TYPE_0, CFG_WR_FMT),
+	       port->base + PCIE_CFG_HEADER0);
+	writel(CFG_HEADER_DW1(where, size), port->base + PCIE_CFG_HEADER1);
+	writel(CFG_HEADER_DW2(where, PCI_FUNC(devfn), PCI_SLOT(devfn), bus),
+	       port->base + PCIE_CFG_HEADER2);
+
+	/* Write Cfgwr data */
+	val = val << 8 * (where & 3);
+	writel(val, port->base + PCIE_CFG_WDATA);
+
+	/* Trigger h/w to transmit Cfgwr TLP */
+	val = readl(port->base + PCIE_APP_TLP_REQ);
+	val |= APP_CFG_REQ;
+	writel(val, port->base + PCIE_APP_TLP_REQ);
+
+	/* Check completion status */
+	return mtk_pcie_check_cfg_cpld(port);
+}
+
+static struct mtk_pcie_port *mtk_pcie_find_port(struct pci_bus *bus,
+						unsigned int devfn)
+{
+	struct mtk_pcie *pcie = bus->sysdata;
+	struct mtk_pcie_port *port;
+	struct pci_dev *dev;
+	struct pci_bus *pbus;
+
+	list_for_each_entry(port, &pcie->ports, list) {
+		if (bus->number == 0 && port->slot == PCI_SLOT(devfn)) {
+			return port;
+		} else if (bus->number != 0) {
+			pbus = bus;
+			do {
+				dev = pbus->self;
+				if (port->slot == PCI_SLOT(dev->devfn))
+					return port;
+
+				pbus = dev->bus;
+			} while (dev->bus->number != 0);
+		}
+	}
+
+	return NULL;
+}
+
+static int mtk_pcie_config_read(struct pci_bus *bus, unsigned int devfn,
+				int where, int size, u32 *val)
+{
+	struct mtk_pcie_port *port;
+	u32 bn = bus->number;
+	int ret;
+
+	port = mtk_pcie_find_port(bus, devfn);
+	if (!port) {
+		*val = ~0;
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	}
+
+	ret = mtk_pcie_hw_rd_cfg(port, bn, devfn, where, size, val);
+	if (ret)
+		*val = ~0;
+
+	return ret;
+}
+
+static int mtk_pcie_config_write(struct pci_bus *bus, unsigned int devfn,
+				 int where, int size, u32 val)
+{
+	struct mtk_pcie_port *port;
+	u32 bn = bus->number;
+
+	port = mtk_pcie_find_port(bus, devfn);
+	if (!port)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	return mtk_pcie_hw_wr_cfg(port, bn, devfn, where, size, val);
+}
+
+static struct pci_ops mtk_pcie_ops_v2 = {
+	.read  = mtk_pcie_config_read,
+	.write = mtk_pcie_config_write,
+};
+
+/*====================regs==================*/
+u32 get_pcie_mac0_data(u32 reg)
+{
+	struct ecnt_pcie *ecnt_pcie=NULL;
+	ecnt_pcie=&ECNT_pcie;
+
+	return readl(ecnt_pcie->mac0_base+ reg);
+}
+
+void set_pcie_mac0_data(u32 reg, u32 val)
+{
+	struct ecnt_pcie *ecnt_pcie=NULL;
+	ecnt_pcie=&ECNT_pcie;
+
+	writel(val, ecnt_pcie->mac0_base + reg); 
+}
+u32 get_pcie_mac1_data(u32 reg)
+{
+	struct ecnt_pcie *ecnt_pcie=NULL;
+	ecnt_pcie=&ECNT_pcie;
+
+	return readl(ecnt_pcie->mac1_base+ reg);
+}
+
+void set_pcie_mac1_data(u32 reg, u32 val)
+{
+	struct ecnt_pcie *ecnt_pcie=NULL;
+	ecnt_pcie=&ECNT_pcie;
+
+	writel(val, ecnt_pcie->mac1_base + reg); 
+}
+
+u32 regRead_PCIe(u32 reg)		
+{	
+	u32 val = 0;
+	switch(reg&0xfffff000)
+		{
+		case 0xbfb00000:
+			val=get_np_scu_data(reg&0xfff);
+			break;
+		#if 0
+		case 0xbfa90000:
+			val=get_pcie_host0_data(reg&0xfff);
+			break;
+		#endif
+		case 0xbfa91000:
+			val=get_pcie_mac0_data(reg&0xfff);
+			break;
+		case 0xbfa92000:
+			val=get_pcie_mac1_data(reg&0xfff);
+			break;
+		}
+	return val;		  
+}		
+void regWrite_PCIe(u32 reg, u32 val)	
+{                                                	
+    
+	switch(reg&0xfffff000)
+		{
+		case 0xbfb00000:
+			set_np_scu_data(reg&0xfff,val);
+			break;
+		#if 0
+		case 0xbfa90000:
+			set_pcie_host0_data(reg&0xfff,val);
+			break;
+		#endif
+		case 0xbfa91000:
+			set_pcie_mac0_data(reg&0xfff,val);
+			break;
+		case 0xbfa92000:
+			set_pcie_mac1_data(reg&0xfff,val);
+			break;
+
+		}
+}
+
+EXPORT_SYMBOL(regRead_PCIe);
+EXPORT_SYMBOL(regWrite_PCIe);
+
+
+/*====================regs==================*/
+#define isRC0_LINKUP		((regRead_PCIe(0xbfa91804) & 0x400) ? 1 : 0)  
+#define isRC1_LINKUP		((regRead_PCIe(0xbfa92804) & 0x400) ? 1 : 0)
+
+int get_rc_port(unsigned char bus,unsigned char dev)
+{
+	int rc = 4;
+
+	if ((bus == 0) && (dev < 2))
+    {
+    	rc = dev;
+    }
+    else if ((bus == 1) && (dev == 0))
+    {           
+        rc = 0;
+    }
+    else if ((bus == 2) && (dev == 0) )
+    {
+        rc = 1;
+    }
+    
+	return rc;
+}
+
+int pcie_write_config_word_extend(unsigned char bus, unsigned char dev,unsigned char func, unsigned int reg, unsigned long int value)
+{
+	unsigned int val,rc;
+	void __iomem *offset=NULL;	
+	struct ecnt_pcie *ecnt_pcie=NULL;
+	ecnt_pcie=&ECNT_pcie;
+
+	rc = get_rc_port(bus,dev);
+
+	if (rc == 0){
+		offset = ecnt_pcie->mac0_base;
+	}else if(rc == 1){
+		offset = ecnt_pcie->mac1_base;
+	}else{
+		return 0xffffffff;
+	}
+
+
+	/*fmt=2|type=4|length=1 */
+	val = (2 << 29) | (4 << 24) | 1;  
+
+	 /* write TLP Header offset 0-3 */
+	 writel(val, 0x460+offset); 
+
+
+	/*write requester ID */
+	val = (rc<<19) | 0x070f;						
+
+	/*write TLP Header offset 4-7 */
+	writel(val, 0x464+offset); 
+	
+	val = (bus << 24) | (dev << 19) |(func << 16) | reg;
+
+	 /*write TLP Header offset 8-11 */
+	 writel(val, 0x468+offset); 
+
+	/*write TLP data */
+	writel(value, 0x470+offset);    
+
+	/*start TLP Requuest */
+	writel(1, 0x488+offset); 
+
+	mdelay(1);
+
+	val = 0;
+
+	/*polling TLP Request status */
+	while((val++)<10)             
+	{
+	 	/*TLP Request finished or timeout */
+		if ((readl(0x488+offset)&0x1)==0)  
+			break;
+		mdelay(1);
+	}
+
+	if (val==10)
+		printk("\nPCIE Write Err: bus = %d, dev = %d Reg = %d",bus,dev,reg);
+
+ 	return 0;
+
+}
+EXPORT_SYMBOL(pcie_write_config_word_extend);
+
+unsigned int pcie_read_config_word_extend(unsigned char bus,unsigned char dev,unsigned char func ,unsigned int reg)
+{
+	unsigned int val,rc;
+	struct ecnt_pcie *ecnt_pcie=NULL;
+	void __iomem *offset=NULL; 
+	ecnt_pcie=&ECNT_pcie;
+	
+	rc = get_rc_port(bus,dev);
+
+
+	if (rc == 0){
+		offset = ecnt_pcie->mac0_base;
+	}else if(rc == 1){
+		offset = ecnt_pcie->mac1_base;
+	}else{
+		return 0xffffffff;
+	}
+
+	/* iniitialize the data reg */
+	//writel(0xffffffff, 0x48c+offset); 
+
+
+	/*fmt=2|type=4|length=1 */
+	if((bus==0&&dev==0)||(bus==0&&dev==1)||(bus==3&&dev==0)||(bus==3&&dev==1))
+	val = (4 << 24) | 1;  
+	else
+	val = (5 << 24) | 1;  	
+	/*write TLP Header offset 0-3 */
+	writel(val, 0x460+offset); 
+
+	/*write requester ID */
+	val = (rc<<19) | 0x070f;//RC0/RC1											
+	/*write TLP Header offset 4-7*/
+	writel(val, 0x464+offset); 
+
+	val = (bus << 24) | (dev << 19) | (func << 16) | reg;
+	/*write TLP Header offset 8-11*/
+	writel(val, 0x468+offset); 
+
+	/*start TLP Requuest*/
+	writel(1, 0x488+offset); 
+
+	mdelay(1);
+
+	val = 0;
+
+	/*polling TLP Request status */
+	while((val++)<10)           
+	{
+		/*TLP Request finished or timeout*/
+		if ((readl(0x488+offset)&0x1)==0)  
+			break;
+		mdelay(1);
+	}
+
+	if (val==10)
+	{
+		printk("\n pcie_read_timeout: bus = %d, dev = %d, func = %d,reg = %x val = %x\n",bus,dev,func,reg,0xffffffff);
+		return 0xffffffff;
+	}
+
+	/*return the data from data reg*/
+	val = readl(0x48c+offset);      
+
+
+	return val;
+}
+EXPORT_SYMBOL(pcie_read_config_word_extend);
+
+int mt7512_pcie_get_pos(char bus,char dev)
+{
+	unsigned int val,pos;
+
+	val = pcie_read_config_word_extend(bus,dev,0,0x34);
+	pos = val&0xff;
+	while(pos && pos != 0xff)
+	{
+		val = pcie_read_config_word_extend(bus,dev,0,pos);
+		if ( (val&0xff) == 0x10)
+			return pos;
+		pos = (val >> 0x08) & 0xff;
+	}
+	return 0;
+}
+
+int  mt7512_pcie_rc0_retrain(void)
+{
+	unsigned int pos = 0, ppos = 0,bus;
+	unsigned int  linkcap, plinkcap,plinksta;
+
+	ppos = mt7512_pcie_get_pos(0,0);//bus0 dev0 rc0
+	bus =  1;                     //bus1 dev0 
+	
+	pos = mt7512_pcie_get_pos(bus,0);  //bus1 dev0
+	
+	if (pos <0x40 || ppos < 0x40)
+		return 0;
+	
+	plinkcap =  pcie_read_config_word_extend(0,0,0,ppos+0x0c);//bus0 dev0 rc0
+	linkcap = pcie_read_config_word_extend(bus,0,0,pos+0x0c);//bus1 dev0 ep0
+	
+	printk("\n mt7512_pcie_rc0_retrain: %x = %08x %x = %08x",pos,linkcap,ppos,plinkcap);
+	
+	if ((linkcap&0x0f)== 1 || (plinkcap&0x0f)==1)
+		return 0;
+	
+	plinksta = pcie_read_config_word_extend(0,0,0,ppos+0x10);//bus0 dev0 rc0
+	if( ((plinksta>>16)&0x0f) ==  (plinkcap&0x0f))
+		return 0;
+
+	plinksta =  pcie_read_config_word_extend(0,0,0,ppos+0x10);//bus0 dev0 rc0
+	plinksta |= 0x20;
+	pcie_write_config_word_extend(0,0,0,ppos+0x10,plinksta);//bus0 dev0 rc0
+	
+	mdelay(1000); 
+	
+	plinksta =  pcie_read_config_word_extend(0,0,0,ppos+0x10);//bus0 dev0 rc0
+	
+	printk("\nRC0 Link Traing Result: %08x",plinksta);//rc0
+	
+	return 1;
+}
+
+
+int  mt7512_pcie_rc1_retrain(void)
+{
+	unsigned int pos = 0, ppos = 0,bus;
+	unsigned int  linkcap, plinkcap,plinksta;
+
+	ppos = mt7512_pcie_get_pos(0,1);
+	bus =  2;
+	
+	pos = mt7512_pcie_get_pos(bus,0);
+	
+	if (pos <0x40 || ppos < 0x40)
+		return 0;
+	
+	plinkcap =  pcie_read_config_word_extend(0,1,0,ppos+0x0c);
+	linkcap = pcie_read_config_word_extend(bus,0,0,pos+0x0c);
+	
+	printk("\n mt7512_pcie_rc1_retrain: %x = %08x %x = %08x",pos,linkcap,ppos,plinkcap);
+	
+	if ((linkcap&0x0f)== 1 || (plinkcap&0x0f)==1)
+		return 0;
+	
+	plinksta = pcie_read_config_word_extend(0,1,0,ppos+0x10);
+	if( ((plinksta>>16)&0x0f) ==  (plinkcap&0x0f))
+		return 0;
+
+	plinksta =  pcie_read_config_word_extend(0,1,0,ppos+0x10);
+	plinksta |= 0x20;
+	pcie_write_config_word_extend(0,1,0,ppos+0x10,plinksta);
+	
+	mdelay(1000); 
+	
+	plinksta =  pcie_read_config_word_extend(0,1,0,ppos+0x10);
+	
+	printk("\nRC1 Link Traing Result: %08x",plinksta);
+	
+	return 1;
+}
+
+void mt7512_pcie_fixup(void)
+{
+	unsigned int val = 0,tmp = 0 ,i = 0;
+	
+#if 0
+	unsigned int msg_addr;
+#endif	
+	if (isRC0_LINKUP)
+	{
+		val =  pcie_read_config_word_extend(0,0,0,0x20);
+		tmp = ((val&0xffff)<<16);
+		val = (val&0xffff0000) + 0x100000;
+		val = val - tmp;
+		i = 0;
+		while(i < 32)
+		{
+			if((1<<i) >= val)
+				break;
+			i++;
+		}
+		regWrite_PCIe(0xbfa91438,tmp | i);   //config RC0 to EP Addr window
+		mdelay(1);
+		regWrite_PCIe(0xbfa91448,0x80);     //enable EP to RC0 access
+		printk("\n mt7512_pcie_fixup: 0x1438 = %x ",tmp | i);
+
+		mt7512_pcie_rc0_retrain();
+
+#if 0
+		printk("\n===========RC0 set conf space MSI of e1000e=============\n");
+		msg_addr=0x1fa910c0;
+		//MSI RC
+		pcie_write_config_word(0,0,0,0x50,0x817005);
+		pcie_write_config_word(0,0,0,0x54,msg_addr);
+		pcie_write_config_word(0,0,0,0x5c,0x00);
+		//MSI EP
+		pcie_write_config_word(0,1,0,0xd0,0x81e005);
+		pcie_write_config_word(0,1,0,0xd4,msg_addr);
+		pcie_write_config_word(0,1,0,0xdc,0x00);
+		printk("\n===========RC0 msg_addr:%x===\n",msg_addr);
+#else
+	printk("\n===========RC0 set conf space INTx=============\n");
+#endif
+
+		
+	}
+	
+	if (isRC1_LINKUP)
+	{
+	
+		val =  pcie_read_config_word_extend(0,1,0,0x20);
+		tmp = ((val&0xffff)<<16);
+		val = (val&0xffff0000) + 0x100000;
+		val = val - tmp;
+		i = 0;
+		while(i < 32)
+		{
+			if((1<<i) >= val)
+				break;
+			i++;
+		}
+		regWrite_PCIe(0xbfa92438,tmp | i);   //config RC1 to EP Addr window
+		mdelay(1);
+		regWrite_PCIe(0xbfa92448,0x80);     //enable EP to RC1 access
+		printk("\n mt7512_pcie_fixup: 0x2438 = %x ",tmp | i);
+		
+		mt7512_pcie_rc1_retrain();
+		
+#if 0
+		printk("\n===========RC1 set conf space MSI of e1000e=============\n");
+		msg_addr=0x1fa920c0;
+		//MSI RC
+		pcie_write_config_word(0,0,1,0x50,0x817005);
+		pcie_write_config_word(0,0,1,0x54,msg_addr);
+		pcie_write_config_word(0,0,1,0x5c,0x00);
+		//MSI EP
+		pcie_write_config_word(0,2,0,0xd0,0x81e005);
+		pcie_write_config_word(0,2,0,0xd4,msg_addr);
+		pcie_write_config_word(0,2,0,0xdc,0x00);
+		printk("\n===========RC1 msg_addr:%x===\n",msg_addr);
+#else
+	printk("\n===========RC1 set conf space INTx=============\n");
+#endif
+	}
+
+	return ;
+}
+EXPORT_SYMBOL(mt7512_pcie_fixup);
+
+
+void mt7512_pcie_reset(void)
+{
+	unsigned int tmp;
+
+	/* enabled PCIe port 1 */
+	tmp = regRead_PCIe(0xbfb00088);
+	regWrite_PCIe(0xbfb00088, (tmp | (1<<22)));
+	mdelay(1);
+	
+	/*first reset to default*///0xbfb00834-pulse-0000_11111_0000
+    {
+    tmp = regRead_PCIe(0xbfb00834);
+    regWrite_PCIe(0xbfb00834, (tmp & (~( (1<<26) | (1<<27) | (1<<29)))));
+    mdelay(1);
+    tmp = regRead_PCIe(0xbfb00834);
+    regWrite_PCIe(0xbfb00834, (tmp | ( (1<<26) | (1<<27) | (1<<29))));
+    mdelay(100);
+    tmp = regRead_PCIe(0xbfb00834);
+    regWrite_PCIe(0xbfb00834, (tmp & (~( (1<<26) | (1<<27) | (1<<29)))));
+    mdelay(5);
+    }
+
+    /*release device*///0xbfb00088-0000_11111
+    {
+    tmp = regRead_PCIe(0xbfb00088);
+    regWrite_PCIe(0xbfb00088, (tmp & (~((1<<29) | (1<<26)))));
+    mdelay(1);
+    tmp = regRead_PCIe(0xbfb00088);
+    regWrite_PCIe(0xbfb00088, (tmp | ((1<<29) | (1<<26))));
+    }
+      
+	/*wait link up*/
+	mdelay(250);
+	//mdelay(2500);
+
+	return ;
+}
+
+int port_num=0;
+static int mtk_pcie_startup_port_v2(struct mtk_pcie_port *port)
+{
+	struct mtk_pcie *pcie = port->pcie;
+	struct resource *mem = &pcie->mem;
+	u32 val;
+	size_t size;
+	int err;
+
+	/*~~~~~~~~~~~~~~~~~~~~~~reset-for-linkup~~~~~~~~~~~~~~~~~~~~~~*/
+	writel(0x804201, port->base + K_GBL_1);
+	writel(0x06040001, port->base + K_CONF_FUNC0_1);
+
+	/* 100ms timeout value should be enough for Gen1/2 training */
+	err = readl_poll_timeout(port->base + PCIE_LINK_STATUS_V2, val,
+				 !!(val & PCIE_PORT_LINKUP_V2), 20,
+				 100 * USEC_PER_MSEC);
+	if (err)
+		return -ETIMEDOUT;
+
+
+	val = readl(port->base + PCIE_LINK_STATUS_V2);
+
+
+
+	/* Set INTx mask */
+#ifdef CONFIG_PCI_MSI
+	if(0==port_num)
+		writel(0x1fa910c0,port->base+PCIE_IMSI_ADDR);  //RC0 e1000e MSI
+	else
+		writel(0x1fa920c0,port->base+PCIE_IMSI_ADDR);  //RC1 e1000e MSI
+	port_num++;
+	val = readl(port->base + PCIE_INT_MASK);
+	val &= ~MSI_MASK;
+	writel(val, port->base + PCIE_INT_MASK);
+#else
+
+	val = readl(port->base + PCIE_INT_MASK);
+	val &= ~INTX_MASK;
+	writel(val, port->base + PCIE_INT_MASK);
+#endif
+	/* Set AHB to PCIe translation windows */
+	size = mem->end - mem->start;
+	val = lower_32_bits(mem->start) | AHB2PCIE_SIZE(fls(size));
+
+	writel(val, port->base + PCIE_AHB_TRANS_BASE0_L);
+
+	val = upper_32_bits(mem->start);
+	writel(val, port->base + PCIE_AHB_TRANS_BASE0_H);
+
+	/* Set PCIe to AXI translation memory space.*/
+	//val = fls(0xffffffff) | WIN_ENABLE;
+	val=0x80;
+	writel(val, port->base + PCIE_AXI_WINDOW0);
+	
+	return 0;
+}
+
+
+
+int irq_num=0;
+
+static int mtk_pcie_setup_irq(struct mtk_pcie_port *port,
+			      struct device_node *node)
+{
+	struct mtk_pcie *pcie = port->pcie;
+	struct device *dev = pcie->dev;
+	struct platform_device *pdev = to_platform_device(dev);
+	int err, irq;
+	
+	struct ecnt_pcie *ecnt_pcie=NULL;
+	ecnt_pcie=&ECNT_pcie;
+	if (!ecnt_pcie)
+		return -ENOMEM;
+
+
+	irq = platform_get_irq(pdev, port->slot);
+
+
+
+	if(0==irq_num)
+		ecnt_pcie->irq_pcie0 = irq;
+	else
+		ecnt_pcie->irq_pcie1 = irq;
+		
+	irq_num++;
+
+	
+	printk("\n==============mtk_pcie_setup_irq=====irq=%d====\n",irq);
+
+	return 0;
+}
+
+static void mtk_pcie_enable_port(struct mtk_pcie_port *port)
+{
+	struct mtk_pcie *pcie = port->pcie;
+	struct device *dev = pcie->dev;
+
+	if (!pcie->soc->startup(port)) {
+		dev_info(dev, "pcie rc %d linkup success\n", port->slot);
+		return;
+	}
+
+	dev_info(dev, "Port%d link down\n", port->slot);
+}
+
+int base_num=0;
+
+
+static int mtk_pcie_parse_port(struct mtk_pcie *pcie,
+			       struct device_node *node,
+			       int slot)
+{
+	struct mtk_pcie_port *port;
+	struct resource *regs;
+	struct device *dev = pcie->dev;
+	struct platform_device *pdev = to_platform_device(dev);
+	int err;
+	struct ecnt_pcie *ecnt_pcie=NULL;
+	ecnt_pcie=&ECNT_pcie;
+	if (!ecnt_pcie)
+		return -ENOMEM;
+
+	port = devm_kzalloc(dev, sizeof(*port), GFP_KERNEL);
+	if (!port)
+		return -ENOMEM;
+
+	err = of_property_read_u32(node, "num-lanes", &port->lane);
+	if (err) {
+		dev_err(dev, "missing num-lanes property\n");
+		return err;
+	}
+
+	regs = platform_get_resource(pdev, IORESOURCE_MEM, slot);
+
+	port->base = devm_ioremap_resource(dev, regs);
+
+
+	if(0==base_num)
+		ecnt_pcie->mac0_base = port->base;
+	else
+		ecnt_pcie->mac1_base = port->base;
+		
+	base_num++;
+
+
+	if (IS_ERR(port->base)) {
+		dev_err(dev, "failed to map port%d base\n", slot);
+		return PTR_ERR(port->base);
+	}
+
+	port->slot = slot;
+	port->pcie = pcie;
+
+	if (pcie->soc->setup_irq) {
+		err = pcie->soc->setup_irq(port, node);
+		if (err)
+			return err;
+	}
+
+	INIT_LIST_HEAD(&port->list);
+	list_add_tail(&port->list, &pcie->ports);
+
+	return 0;
+}
+
+static int mtk_pcie_setup(struct mtk_pcie *pcie)
+{
+	struct device *dev = pcie->dev;
+	struct device_node *node = dev->of_node, *child;
+	struct mtk_pcie_port *port, *tmp;
+	int err;
+	u32 tmp_reg;
+
+	for_each_available_child_of_node(node, child) {
+		int slot;
+
+		err = of_pci_get_devfn(child);
+		if (err < 0) {
+			dev_err(dev, "failed to parse devfn: %d\n", err);
+			goto error_put_node;
+		}
+
+		slot = PCI_SLOT(err);
+
+		err = mtk_pcie_parse_port(pcie, child, slot);
+		if (err)
+			goto error_put_node;
+	}
+
+
+
+	/* enable each port, and then check link status */
+
+#if 1
+	/*before reset host,need to pull device low*/
+	tmp_reg = regRead_PCIe(0xbfb00088);
+	regWrite_PCIe(0xbfb00088, (tmp_reg & (~((1<<29) | (1<<26)))));
+	mdelay(1);
+	
+	printk("===EN7523 PCIe init");
+	mt7512_pcie_reset();
+#endif
+
+	list_for_each_entry_safe(port, tmp, &pcie->ports, list)
+		{mtk_pcie_enable_port(port);}
+
+
+
+	return 0;
+error_put_node:	
+	of_node_put(child);	
+	return err;
+}
+
+int pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+
+	int irq0=0,irq1=0;
+	struct ecnt_pcie *ecnt_pcie=NULL;
+	ecnt_pcie=&ECNT_pcie;
+	
+	printk("\n====pcibios_map_irq===slot=%d====\n",slot);
+
+
+	irq0=ecnt_pcie->irq_pcie0;
+	printk("\n====pcibios_map_irq===irq0=%d===\n",irq0);
+
+	irq1=ecnt_pcie->irq_pcie1;	
+	printk("\n====pcibios_map_irq===irq1=%d===\n",irq1);
+
+	if (slot == 0)
+		return irq0;
+	else if(slot == 1)
+		return irq1;
+
+	return -EINVAL;
+}
+
+static int mtk_pcie_register_host(struct pci_host_bridge *host)
+{
+	struct mtk_pcie *pcie = pci_host_bridge_priv(host);
+	struct pci_bus *child;
+	int err;
+
+	host->ops = pcie->soc->ops;
+
+	host->map_irq = pcibios_map_irq;
+
+	host->sysdata = pcie;
+	host->msi_domain = !pcie->soc->has_msi;
+
+	err = pci_scan_root_bus_bridge(host);
+	if (err < 0)
+		return err;
+
+	pci_bus_size_bridges(host->bus);
+
+	pci_bus_assign_resources(host->bus);
+
+	list_for_each_entry(child, &host->bus->children, node)
+		{pcie_bus_configure_settings(child);}
+
+	pci_bus_add_devices(host->bus);
+	//pci_fixup_irqs(pci_common_swizzle, pcibios_map_irq);
+
+	return 0;
+}
+
+static int mtk_pcie_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mtk_pcie *pcie;
+	struct pci_host_bridge *host;
+	int err;
+	u32 tmp_reg;
+
+	printk("\n===============PCIe Probing====================\n");
+	host = devm_pci_alloc_host_bridge(dev, sizeof(*pcie));
+	if (!host)
+		return -ENOMEM;
+
+	pcie = pci_host_bridge_priv(host);
+
+	pcie->dev = dev;
+	pcie->soc = of_device_get_match_data(dev);
+	platform_set_drvdata(pdev, pcie);
+	INIT_LIST_HEAD(&pcie->ports);
+
+	err = mtk_pcie_setup(pcie);
+	if (err)
+		return err;
+
+	//check whether PCIe exsits or not
+	tmp_reg = regRead_PCIe(0xbfa91100);
+	printk("\n===============PCIe check===tmp_reg=========%x===========\n",tmp_reg);
+	if(0x081014c3!=tmp_reg)
+		return 0;		
+
+	err = mtk_pcie_register_host(host);
+	printk("\n===============PCIe Probing ERR %d====================\n", err);
+	if (err)
+		return err;
+
+
+
+	mt7512_pcie_fixup();
+
+	return 0;
+
+}
+
+
+
+static const struct mtk_pcie_soc mtk_pcie_soc_v2 = {
+	.has_msi = false,
+	.ops = &mtk_pcie_ops_v2,
+	.startup = mtk_pcie_startup_port_v2,
+	.setup_irq = mtk_pcie_setup_irq,
+};
+
+static const struct of_device_id mtk_pcie_ids[] = {
+	{ .compatible = "ecnt,pcie-ecnt", .data = &mtk_pcie_soc_v2 },
+	{},
+};
+
+static struct platform_driver mtk_pcie_driver = {
+	.probe = mtk_pcie_probe,
+	.driver = {
+		.name = "ecnt-pcie",
+		.of_match_table = mtk_pcie_ids,
+		.suppress_bind_attrs = true,
+	},
+};
+builtin_platform_driver(mtk_pcie_driver);
+
--- a/drivers/pci/controller/Makefile
+++ b/drivers/pci/controller/Makefile
@@ -59,3 +59,4 @@ obj-$(CONFIG_ARM64) += pci-thunder-pem.o
 obj-$(CONFIG_ARM64) += pci-xgene.o
 endif
 endif
+obj-$(CONFIG_PCI) += pcie-ecnt.o
--- /dev/null
+++ b/include/linux/clk/en7523.h
@@ -0,0 +1,7 @@
+#ifndef _CLOCK_AIROHA_EN7523_H_
+#define _CLOCK_AIROHA_EN7523_H_
+
+u32 get_np_scu_data(u32 reg);
+void set_np_scu_data(u32 reg, u32 val);
+
+#endif
